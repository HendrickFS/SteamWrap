/**
 * Simple client-side report image generator.
 *
 * Usage:
 * import generateReportImage from '../services/reportImage';
 * const dataUrl = await generateReportImage(report);
 * // then set an <img src={dataUrl} /> or download it
 */

type Report = {
  steamName?: string | null;
  steamId?: string;
  steamAvatar?: string | null;
  totalHours?: number;
  topGames?: Array<{ name: string; hours?: number; icon?: string }>;
  detailedGames?: any[];
};

async function loadImage(url?: string | null): Promise<HTMLImageElement | null> {
  if (!url) return null;
  return await new Promise((res) => {
    const img = new Image();
    img.crossOrigin = 'Anonymous';
    img.onload = () => res(img);
    img.onerror = () => res(null);
    img.src = url as string;
  });
}

function roundRect(ctx: CanvasRenderingContext2D, x: number, y: number, w: number, h: number, r: number) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  ctx.fill();
}

export default async function generateReportImage(report: Report): Promise<string> {
  const width = 1200;
  const height = 630;
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d')!;

  // Background
  ctx.fillStyle = '#0f1724';
  ctx.fillRect(0, 0, width, height);

  // Card background
  ctx.fillStyle = 'rgba(255,255,255,0.03)';
  roundRect(ctx, 40, 40, width - 80, height - 80, 16);

  // Avatar
  const avatar = await loadImage(report.steamAvatar ?? null);
  const avatarX = 80;
  const avatarY = 80;
  const avatarSize = 120;
  if (avatar) {
    // circular clip
    ctx.save();
    ctx.beginPath();
    ctx.arc(avatarX + avatarSize / 2, avatarY + avatarSize / 2, avatarSize / 2, 0, Math.PI * 2);
    ctx.closePath();
    ctx.clip();
    ctx.drawImage(avatar, avatarX, avatarY, avatarSize, avatarSize);
    ctx.restore();
  } else {
    ctx.fillStyle = '#1f2937';
    ctx.fillRect(avatarX, avatarY, avatarSize, avatarSize);
  }

  // Title
  ctx.fillStyle = '#fff';
  ctx.font = '700 36px Inter, Arial, sans-serif';
  ctx.fillText(report.steamName || report.steamId || 'Steam User', avatarX + avatarSize + 24, avatarY + 40);

  // Subtitle (id)
  ctx.fillStyle = '#9ca3af';
  ctx.font = '400 16px Inter, Arial, sans-serif';
  if (report.steamId) ctx.fillText(report.steamId, avatarX + avatarSize + 24, avatarY + 70);

  // Stats block
  ctx.fillStyle = '#fff';
  ctx.font = '600 28px Inter, Arial, sans-serif';
  ctx.fillText(`${report.totalHours ?? 0}`, avatarX + avatarSize + 24, avatarY + 130);
  ctx.font = '400 14px Inter, Arial, sans-serif';
  ctx.fillStyle = '#9ca3af';
  ctx.fillText('Total hours (last 14 days)', avatarX + avatarSize + 24, avatarY + 152);

  // Top games
  ctx.fillStyle = '#fff';
  ctx.font = '700 20px Inter, Arial, sans-serif';
  ctx.fillText('Top games', 80, avatarY + avatarSize + 60);

  const top = report.topGames || [];
  const thumbSize = 88;
  for (let i = 0; i < Math.min(4, top.length); i++) {
    const g = top[i];
    const x = 80 + i * (thumbSize + 24);
    const y = avatarY + avatarSize + 80;
    const img = await loadImage(g.icon ?? null);
    if (img) {
      roundRect(ctx, x, y, thumbSize, thumbSize, 8);
      ctx.drawImage(img, x, y, thumbSize, thumbSize);
    } else {
      ctx.fillStyle = '#172033';
      roundRect(ctx, x, y, thumbSize, thumbSize, 8);
    }

    // name
    ctx.fillStyle = '#fff';
    ctx.font = '600 14px Inter, Arial, sans-serif';
    const name = g.name || 'Unknown';
    ctx.fillText(name, x, y + thumbSize + 20);

    // hours
    ctx.fillStyle = '#9ca3af';
    ctx.font = '400 12px Inter, Arial, sans-serif';
    ctx.fillText(`${g.hours ?? 0} hrs`, x, y + thumbSize + 38);
  }

  // Footer note
  ctx.fillStyle = '#9ca3af';
  ctx.font = '400 12px Inter, Arial, sans-serif';
  ctx.fillText('Generated by SteamWrap', 80, height - 50);

  return canvas.toDataURL('image/png');
}
